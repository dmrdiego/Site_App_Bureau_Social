perfeito — seguem **diffs prontos** (no formato `git diff --patch`) para você colar/aplicar no repositório. Estão separados por arquivo. Se algum bloco não aplicar automaticamente, basta copiar o conteúdo novo para o arquivo indicado.

---

# 1) `package.json` — scripts e dependências úteis

```diff
diff --git a/package.json b/package.json
index 1111111..2222222 100644
--- a/package.json
+++ b/package.json
@@ -1,12 +1,20 @@
 {
   "name": "rest-express",
   "private": true,
   "scripts": {
     "dev": "NODE_ENV=development tsx server/index.ts",
-    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
+    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
     "start": "NODE_ENV=production node dist/index.js",
-    "check": "tsc",
-    "db:push": "drizzle-kit push"
+    "check": "tsc",
+    "db:push": "drizzle-kit push",
+    "seed": "tsx seed_documents.ts",
+    "typecheck": "tsc --noEmit"
   },
+  "engines": { "node": ">=20" },
   "dependencies": {
+    "compression": "^1.7.4",
+    "cors": "^2.8.5",
+    "express-rate-limit": "^7.1.5",
+    "helmet": "^7.1.0",
+    "multer": "^1.4.5"
   },
   "devDependencies": {
     "drizzle-kit": "...",
     "esbuild": "...",
     "postcss": "...",
     "tailwindcss": "..."
   }
 }
```

> Depois rode **`npm i`** para instalar `helmet`, `compression`, `rate-limit`, `cors`, `multer` (se algum já existir, o patch ignora).

---

# 2) `server/storage.ts` — CRUD de documentos + presenças

```diff
diff --git a/server/storage.ts b/server/storage.ts
index 1111111..2222222 100644
--- a/server/storage.ts
+++ b/server/storage.ts
@@ -1,6 +1,8 @@
 import { db } from "./db";
 import { eq, desc } from "drizzle-orm";
-import { users, documents, assemblies, votingItems, votes, presences } from "@shared/schema";
+import { users, documents, assemblies, votingItems, votes, presences } from "@shared/schema";
+import type { Document, InsertDocument, Presence } from "@shared/schema";
+
 // ... (demais imports/Tipos)

 export const storage = {
@@ -200,6 +202,63 @@ export const storage = {
   // Documents
-  getAllDocuments(): Promise<Document[]>;
-  getDocumentById(id: number): Promise<Document | undefined>;
-  createDocument(document: InsertDocument): Promise<Document>;
-  getDocumentsByType(type: string): Promise<Document[]>;
+  async getAllDocuments(): Promise<Document[]> {
+    return await db.select().from(documents).orderBy(desc(documents.createdAt));
+  },
+
+  async getDocumentById(id: number): Promise<Document | undefined> {
+    const result = await db.select().from(documents).where(eq(documents.id, id));
+    return result[0];
+  },
+
+  async createDocument(payload: InsertDocument): Promise<Document> {
+    const inserted = await db.insert(documents).values(payload).returning();
+    return inserted[0];
+  },
+
+  async updateDocument(id: number, data: Partial<Document>): Promise<Document | undefined> {
+    const updated = await db.update(documents).set(data).where(eq(documents.id, id)).returning();
+    return updated[0];
+  },
+
+  async deleteDocument(id: number): Promise<void> {
+    await db.delete(documents).where(eq(documents.id, id));
+  },
+
   async getDocumentsByType(type: string): Promise<Document[]> {
     return await db
       .select()
       .from(documents)
       .where(eq(documents.tipo, type))
       .orderBy(desc(documents.createdAt));
   },
 
   async getDocumentsByAssembly(assemblyId: number): Promise<Document[]> {
     return await db
       .select()
       .from(documents)
       .where(eq(documents.assemblyId, assemblyId))
       .orderBy(desc(documents.createdAt));
   },
+
+  // Presences export helper
+  async getPresencesByAssembly(assemblyId: number): Promise<Presence[]> {
+    return await db.select().from(presences).where(eq(presences.assemblyId, assemblyId));
+  },
+
+  // Votes export helper (caso não exista)
+  async getVotesByVotingItem(votingItemId: number) {
+    return await db.select().from(votes).where(eq(votes.votingItemId, votingItemId));
+  },
 };
```

---

# 3) `server/routes.ts` — upload/edição/remoção de documentos, broadcast de e-mails, exports CSV, health/debug

```diff
diff --git a/server/routes.ts b/server/routes.ts
index 1111111..2222222 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -1,15 +1,29 @@
 // IMPORTANT: Based on Replit Auth blueprint (javascript_log_in_with_replit)
 import type { Express, Request, Response } from "express";
 import { createServer, type Server } from "http";
-import multer from "multer";
-import { Client } from "@replit/object-storage";
+import multer from "multer";
+import { Client } from "@replit/object-storage";
 import { storage } from "./storage";
 import { setupAuth, isAuthenticated } from "./replitAuth";
 import type { User } from "@shared/schema";
 import { generateAssemblyMinutesPDF } from "./pdfGenerator";
 import {
   sendEmail,
   createNovaAssembleiaEmail,
   createAtaDisponivelEmail,
   createProcuracaoRecebidaEmail,
 } from "./emailService";
+import helmet from "helmet";
+import compression from "compression";
+import cors from "cors";
+import rateLimit from "express-rate-limit";
+import os from "node:os";
+
+// Object Storage client
+const objectClient = new Client();
+const bucket = objectClient.bucket(process.env.OBJECT_STORAGE_BUCKET || "default");
+
+// helpers
+const toCSV = (rows: any[]) =>
+  [Object.keys(rows[0] || {}).join(","), ...rows.map(r => Object.values(r).join(","))].join("\n");
 
 // ...
 
@@ -30,6 +44,19 @@ export function registerRoutes(app: Express, server: Server) {
   // existing middlewares
   app.use(express.json());
+  app.use(helmet({ contentSecurityPolicy: false }));
+  app.use(compression());
+  app.use(cors());
+  app.use(rateLimit({ windowMs: 60_000, max: 300 }));
+
+  // Health & Debug
+  app.get("/health", (_req, res) => res.json({ ok: true, t: Date.now() }));
+  app.get("/__debug", (req, res) => {
+    if (process.env.NODE_ENV === "production" && req.query.key !== process.env.SESSION_SECRET) {
+      return res.status(403).send("forbidden");
+    }
+    res.json({ node: process.version, os: `${os.platform()} ${os.arch()}`, env: { NODE_ENV: process.env.NODE_ENV, PORT: process.env.PORT, DATABASE_URL: !!process.env.DATABASE_URL } });
+  });
 
   // ===== Auth adapters =====
   function getUserId(req: any): string {
@@ -65,6 +92,23 @@ export function registerRoutes(app: Express, server: Server) {
   const upload = multer({
     storage: multer.memoryStorage(),
     limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
   });
 
+  // ===== Documents CRUD =====
+  app.post("/api/documents", requireAdmin, upload.single("file"), async (req: Request, res: Response) => {
+    try {
+      const { titulo, tipo, visivelPara = "todos", assemblyId } = req.body as any;
+      if (!req.file) return res.status(400).json({ message: "Arquivo é obrigatório" });
+      const key = `docs/${Date.now()}_${req.file.originalname}`;
+      await bucket.upload(key, req.file.buffer, { contentType: req.file.mimetype });
+      const doc = await storage.createDocument({
+        titulo, tipo, visivelPara,
+        assemblyId: assemblyId ? Number(assemblyId) : null,
+        filePath: key, fileSize: req.file.size, uploadedBy: getUserId(req)
+      });
+      res.status(201).json(doc);
+    } catch (e:any) { res.status(500).json({ message: "Falha no upload", detail: e?.message }); }
+  });
+
+  app.put("/api/documents/:id", requireAdmin, async (req, res) => {
+    try {
+      const id = Number(req.params.id);
+      const partial = (({ titulo, tipo, visivelPara, assemblyId }) => ({ titulo, tipo, visivelPara, assemblyId }))(req.body || {});
+      const updated = await storage.updateDocument(id, partial as any);
+      res.json(updated);
+    } catch (e:any) { res.status(500).json({ message: "Falha ao atualizar documento", detail: e?.message }); }
+  });
+
+  app.delete("/api/documents/:id", requireAdmin, async (req, res) => {
+    try {
+      const id = Number(req.params.id);
+      const doc = await storage.getDocumentById(id);
+      if (!doc) return res.status(404).json({ message: "Documento não encontrado" });
+      await bucket.delete(doc.filePath);
+      await storage.deleteDocument(id);
+      res.status(204).end();
+    } catch (e:any) { res.status(500).json({ message: "Falha ao excluir documento", detail: e?.message }); }
+  });
+
   // ... (demais rotas já existentes)
 
+  // ===== Votações/Presenças Export CSV =====
+  app.get("/api/voting-items/:id/export", requireAdmin, async (req, res) => {
+    const id = Number(req.params.id);
+    const rows = await storage.getVotesByVotingItem(id);
+    const csv = rows.length ? toCSV(rows) : "no_data";
+    res.type("text/csv").attachment(`votacao_${id}.csv`).send(csv);
+  });
+
+  app.get("/api/assemblies/:id/presences/export", requireAdmin, async (req, res) => {
+    const id = Number(req.params.id);
+    const rows = await storage.getPresencesByAssembly(id);
+    const csv = rows.length ? toCSV(rows) : "no_data";
+    res.type("text/csv").attachment(`presencas_${id}.csv`).send(csv);
+  });
+
+  // ===== Broadcast e-mail (admin) =====
+  app.post("/api/admin/email/broadcast", requireAdmin, async (req, res) => {
+    const { subject, html, segmento = "todos", testePara } = req.body || {};
+    if (!subject || !html) return res.status(400).json({ message: "subject e html são obrigatórios" });
+    if (testePara) { await sendEmail({ to: testePara, subject, html }); return res.json({ preview: true }); }
+    const users = await storage.getAllUsers();
+    const filtered = users.filter(u => {
+      if (segmento === "direcao") return u.papel === "direcao";
+      if (segmento === "ativos") return u.ativo;
+      return true;
+    });
+    // envio em lotes simples
+    const chunk = 100;
+    for (let i = 0; i < filtered.length; i += chunk) {
+      await Promise.all(filtered.slice(i, i + chunk).map(u => sendEmail({ to: u.email, subject, html })));
+    }
+    res.json({ total: filtered.length });
+  });
 }
```

> **Obs.:** se a API do `@replit/object-storage` no seu projeto estiver diferente, ajuste `bucket.upload`/`bucket.delete` conforme a lib que você já usa. Mantive a ideia central (chave `docs/<timestamp>_nome.ext>`).

---

# 4) `client/src/pages/Documentos.tsx` — upload/editar/excluir + filtros

```diff
diff --git a/client/src/pages/Documentos.tsx b/client/src/pages/Documentos.tsx
index 1111111..2222222 100644
--- a/client/src/pages/Documentos.tsx
+++ b/client/src/pages/Documentos.tsx
@@ -1,10 +1,174 @@
-import React from "react";
+import React, { useMemo, useState } from "react";
 import { useQuery, useMutation } from "@tanstack/react-query";
 import { apiRequest, queryClient } from "@/lib/queryClient";
 import { Button } from "@/components/ui/button";
+import { Input } from "@/components/ui/input";
+import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
+import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
+import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
+import { Badge } from "@/components/ui/badge";
+import { Trash2, Upload, Edit2, Download } from "lucide-react";
+import { useToast } from "@/hooks/use-toast";
 
 export default function Documentos() {
-  const docs = useQuery({ queryKey: ["documents"], queryFn: async () => (await apiRequest("/api/documents")).json() });
-  return <div>Documentos</div>;
+  const { toast } = useToast();
+  const [busca, setBusca] = useState("");
+  const [tipo, setTipo] = useState<string>("todos");
+  const [visivel, setVisivel] = useState<string>("todos");
+
+  const docs = useQuery({
+    queryKey: ["documents"],
+    queryFn: async () => (await apiRequest("/api/documents")).json(),
+  });
+
+  const uploadMutation = useMutation({
+    mutationFn: async (formData: FormData) =>
+      fetch("/api/documents", { method: "POST", body: formData }).then(r => {
+        if (!r.ok) throw new Error("Falha no upload");
+        return r.json();
+      }),
+    onSuccess: () => {
+      queryClient.invalidateQueries({ queryKey: ["documents"] });
+      toast({ title: "Sucesso", description: "Documento enviado." });
+    },
+    onError: (e: any) => toast({ title: "Erro", description: e?.message, variant: "destructive" }),
+  });
+
+  const deleteMutation = useMutation({
+    mutationFn: async (id: number) => {
+      const r = await apiRequest(`/api/documents/${id}`, { method: "DELETE" });
+      if (!r.ok) throw new Error("Falha ao excluir");
+    },
+    onSuccess: () => {
+      queryClient.invalidateQueries({ queryKey: ["documents"] });
+      toast({ title: "Excluído", description: "Documento removido." });
+    },
+    onError: (e: any) => toast({ title: "Erro", description: e?.message, variant: "destructive" }),
+  });
+
+  const updateMutation = useMutation({
+    mutationFn: async ({ id, data }: { id: number; data: any }) => {
+      const r = await apiRequest(`/api/documents/${id}`, {
+        method: "PUT",
+        body: JSON.stringify(data),
+        headers: { "Content-Type": "application/json" },
+      });
+      if (!r.ok) throw new Error("Falha ao atualizar");
+      return r.json();
+    },
+    onSuccess: () => {
+      queryClient.invalidateQueries({ queryKey: ["documents"] });
+      toast({ title: "Atualizado", description: "Metadados salvos." });
+    },
+    onError: (e: any) => toast({ title: "Erro", description: e?.message, variant: "destructive" }),
+  });
+
+  const filtered = useMemo(() => {
+    const items = docs.data || [];
+    return items.filter((d: any) => {
+      const okBusca = !busca || d.titulo?.toLowerCase().includes(busca.toLowerCase());
+      const okTipo = tipo === "todos" || d.tipo === tipo;
+      const okVisivel = visivel === "todos" || d.visivelPara === visivel;
+      return okBusca && okTipo && okVisivel;
+    });
+  }, [docs.data, busca, tipo, visivel]);
+
+  const onUpload = (files: FileList | null) => {
+    if (!files || !files.length) return;
+    Array.from(files).forEach((file) => {
+      const fd = new FormData();
+      fd.append("file", file);
+      fd.append("titulo", file.name);
+      fd.append("tipo", "arquivo");
+      fd.append("visivelPara", "todos");
+      uploadMutation.mutate(fd);
+    });
+  };
+
+  return (
+    <div className="space-y-6">
+      <Card>
+        <CardHeader className="flex flex-row items-center justify-between">
+          <CardTitle>Documentos</CardTitle>
+          <Dialog>
+            <DialogTrigger asChild>
+              <Button><Upload className="w-4 h-4 mr-2" />Enviar</Button>
+            </DialogTrigger>
+            <DialogContent>
+              <DialogHeader><DialogTitle>Enviar documentos</DialogTitle></DialogHeader>
+              <Input type="file" multiple onChange={(e) => onUpload(e.target.files)} />
+              <p className="text-sm text-muted-foreground">Até 10MB por arquivo.</p>
+            </DialogContent>
+          </Dialog>
+        </CardHeader>
+        <CardContent className="space-y-4">
+          <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
+            <Input placeholder="Buscar por título..." value={busca} onChange={(e)=>setBusca(e.target.value)} />
+            <Select value={tipo} onValueChange={setTipo}>
+              <SelectTrigger><SelectValue placeholder="Tipo" /></SelectTrigger>
+              <SelectContent>
+                <SelectItem value="todos">Todos</SelectItem>
+                <SelectItem value="ata">Ata</SelectItem>
+                <SelectItem value="regulamento">Regulamento</SelectItem>
+                <SelectItem value="relatorio">Relatório</SelectItem>
+                <SelectItem value="arquivo">Arquivo</SelectItem>
+              </SelectContent>
+            </Select>
+            <Select value={visivel} onValueChange={setVisivel}>
+              <SelectTrigger><SelectValue placeholder="Visível para" /></SelectTrigger>
+              <SelectContent>
+                <SelectItem value="todos">Todos</SelectItem>
+                <SelectItem value="admin">Admin</SelectItem>
+                <SelectItem value="direção">Direção</SelectItem>
+              </SelectContent>
+            </Select>
+          </div>
+
+          <div className="overflow-x-auto">
+            <table className="w-full text-sm">
+              <thead>
+                <tr className="text-left border-b">
+                  <th className="py-2 pr-2">Título</th>
+                  <th className="py-2 pr-2">Tipo</th>
+                  <th className="py-2 pr-2">Visível</th>
+                  <th className="py-2 pr-2">Tamanho</th>
+                  <th className="py-2 pr-2">Ações</th>
+                </tr>
+              </thead>
+              <tbody>
+              {(filtered || []).map((d:any) => (
+                <tr key={d.id} className="border-b last:border-0">
+                  <td className="py-2 pr-2">{d.titulo}</td>
+                  <td className="py-2 pr-2"><Badge>{d.tipo}</Badge></td>
+                  <td className="py-2 pr-2">{d.visivelPara}</td>
+                  <td className="py-2 pr-2">{d.fileSize ? `${(d.fileSize/1024).toFixed(1)} KB` : "-"}</td>
+                  <td className="py-2 pr-2 flex gap-2">
+                    <Button variant="secondary" size="sm" onClick={() => window.open(`/api/documents/${d.id}/download`, "_blank")}>
+                      <Download className="w-4 h-4 mr-1" /> Baixar
+                    </Button>
+                    <Button variant="outline" size="sm" onClick={() => updateMutation.mutate({ id: d.id, data: { titulo: prompt("Novo título", d.titulo) || d.titulo } })}>
+                      <Edit2 className="w-4 h-4 mr-1" /> Editar
+                    </Button>
+                    <Button variant="destructive" size="sm" onClick={() => confirm("Excluir documento?") && deleteMutation.mutate(d.id)}>
+                      <Trash2 className="w-4 h-4 mr-1" /> Excluir
+                    </Button>
+                  </td>
+                </tr>
+              ))}
+              </tbody>
+            </table>
+          </div>
+        </CardContent>
+      </Card>
+    </div>
+  );
 }
```

---

# 5) **Nova página** `client/src/pages/Comunicacoes.tsx` — envio de e-mail (broadcast)

```diff
diff --git a/client/src/pages/Comunicacoes.tsx b/client/src/pages/Comunicacoes.tsx
new file mode 100644
--- /dev/null
+++ b/client/src/pages/Comunicacoes.tsx
@@ -0,0 +1,140 @@
+import React, { useState } from "react";
+import { useMutation } from "@tanstack/react-query";
+import { apiRequest } from "@/lib/queryClient";
+import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
+import { Input } from "@/components/ui/input";
+import { Textarea } from "@/components/ui/textarea";
+import { Button } from "@/components/ui/button";
+import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from "@/components/ui/select";
+import { useToast } from "@/hooks/use-toast";
+
+export default function Comunicacoes() {
+  const { toast } = useToast();
+  const [subject, setSubject] = useState("");
+  const [html, setHtml] = useState("");
+  const [segmento, setSegmento] = useState("todos");
+  const [testePara, setTestePara] = useState("");
+
+  const mutation = useMutation({
+    mutationFn: async (body: any) => {
+      const r = await apiRequest("/api/admin/email/broadcast", {
+        method: "POST",
+        headers: { "Content-Type": "application/json" },
+        body: JSON.stringify(body),
+      });
+      if (!r.ok) throw new Error("Falha ao enviar");
+      return r.json();
+    },
+    onSuccess: (data: any) => toast({ title: "OK", description: data.preview ? "E-mail de teste enviado." : `Enviado para ${data.total} destinatários.` }),
+    onError: (e: any) => toast({ title: "Erro", description: e?.message, variant: "destructive" }),
+  });
+
+  return (
+    <Card>
+      <CardHeader>
+        <CardTitle>Comunicações (Admin)</CardTitle>
+      </CardHeader>
+      <CardContent className="space-y-4">
+        <Input placeholder="Assunto" value={subject} onChange={(e)=>setSubject(e.target.value)} />
+        <Select value={segmento} onValueChange={setSegmento}>
+          <SelectTrigger><SelectValue placeholder="Segmento" /></SelectTrigger>
+          <SelectContent>
+            <SelectItem value="todos">Todos os associados</SelectItem>
+            <SelectItem value="ativos">Apenas ativos</SelectItem>
+            <SelectItem value="direcao">Direção</SelectItem>
+          </SelectContent>
+        </Select>
+        <Textarea placeholder="Conteúdo (HTML ou Markdown renderizado no servidor)" className="min-h-[200px]" value={html} onChange={(e)=>setHtml(e.target.value)} />
+        <div className="flex gap-2">
+          <Input placeholder="Enviar teste para..." value={testePara} onChange={(e)=>setTestePara(e.target.value)} />
+          <Button onClick={()=>mutation.mutate({ subject, html, segmento, testePara })} disabled={!testePara || !subject || !html}>Enviar teste</Button>
+        </div>
+        <div className="flex justify-end">
+          <Button onClick={()=>mutation.mutate({ subject, html, segmento })} disabled={!subject || !html}>Enviar</Button>
+        </div>
+      </CardContent>
+    </Card>
+  );
+}
```

---

# 6) **Rotas React** — adicionar a página “Comunicações” e garantir rota de Documentos

```diff
diff --git a/client/src/App.tsx b/client/src/App.tsx
index 1111111..2222222 100644
--- a/client/src/App.tsx
+++ b/client/src/App.tsx
@@ -1,12 +1,14 @@
 import { Switch, Route } from "wouter";
 import Dashboard from "@/pages/Dashboard";
 import Documentos from "@/pages/Documentos";
+import Comunicacoes from "@/pages/Comunicacoes";
 // ... demais imports
 
 export default function App() {
   return (
     <Switch>
       <Route path="/" component={Landing} />
       <Route path="/dashboard" component={Dashboard} />
       <Route path="/documentos" component={Documentos} />
+      <Route path="/comunicacoes" component={Comunicacoes} />
       {/* ...demais rotas existentes */}
     </Switch>
   );
 }
```

---

# 7) **Sidebar** — link para “Comunicações”

```diff
diff --git a/client/src/components/AppSidebar.tsx b/client/src/components/AppSidebar.tsx
index 1111111..2222222 100644
--- a/client/src/components/AppSidebar.tsx
+++ b/client/src/components/AppSidebar.tsx
@@ -50,6 +50,10 @@ export function AppSidebar() {
         <NavItem href="/documentos" label="Documentos" icon="file" />
         {/* ... existentes */}
+        <div className="mt-4 text-xs uppercase text-muted-foreground px-4">Admin</div>
+        <NavItem href="/comunicacoes" label="Comunicações" icon="mail" />
+
       </nav>
 }
```

---

## Depois de aplicar os patches

1. `npm i` (garantir novas deps).
2. **Secrets** no Replit:

   * `DATABASE_URL` (Postgres)
   * `RESEND_API_KEY` (Resend)
   * `SESSION_SECRET` (protege `/__debug`)
3. `npm run db:push`
4. **Run** (dev): `npm run dev`
5. **Deploy**: use o fluxo padrão do Replit (já configurado em `.replit`)

---

Quer que eu gere também **os arquivos completos** (não só diffs) para você baixar e colar? Posso te entregar os conteúdos finais de cada arquivo conforme os patches acima.
